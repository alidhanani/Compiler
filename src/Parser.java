import java.util.ArrayList;
import java.util.Stack;

/**
 *
 * a recursive descent LL(1) parser using pushdown automata
 *
 * @author Dhanani, Ali
 *
 */

public class Parser {
    /**
     * stack to store varriables
     */
    private Stack stack;
    /**
     * tokens generated by the LexicalAnalyzer
     */
    private LexicalAnalyzer tokens;
    /**
     * current token
     */
    private Symbol token;
    /**
     * leftmost derivations rules
     */
    private ArrayList rules;

    /**
     * 
     * @param tokens tokens generated by the LexicalAnalyzer
     */
    public Parser(LexicalAnalyzer tokens) {
        stack = new Stack();
        this.tokens = tokens;
        this.rules = new ArrayList();

    }

    /**
     * get the next token from tokens and affect it to token
     */
    private void NextToken() {
        try {
            this.token = this.tokens.nextToken();
        } catch (Exception e) {
            System.out.println("EOF");
        }

    }

    /**
     * start the Parser and the ParseTree
     * 
     * @return ParseTree
     */
    public ParseTree startParse() {
        // push the initial varriable to the stuck
        this.stack.push(Varriables.Program);
        // get the current token
        NextToken();
        // see if the current token is BEGINPROG and do the lefmost derivation of
        // varriable <program>
        if (this.token.getType().equals(LexicalUnit.BEGINPROG)) {
            return new ParseTree(new Symbol(LexicalUnit.NonTerminal, "PROGRAM"), program());
        } else {
            Syntaxerror(this.token);
            return new ParseTree(new Symbol(LexicalUnit.NonTerminal, "PROGRAM"));
        }

    }

    /**
     * lefmost derivation of the varriable <program> , we remove the varriable
     * <program> from the stuck and push the derivations, if we have a terminal on
     * the head of the stuck we Match and add it to the parsetree ,else we call the
     * functions to derivate the varriable
     * 
     * @return ParseTree of Program
     */
    private ArrayList<ParseTree> program() {
        // program ParseTree
        ArrayList<ParseTree> program = new ArrayList<ParseTree>();
        this.stack.pop();
        this.rules.add(1);
        this.stack.add(LexicalUnit.ENDPROG);
        this.stack.add(Varriables.Code);
        this.stack.add(Varriables.Varriables);
        this.stack.add(LexicalUnit.ENDLINE);
        this.stack.add(LexicalUnit.PROGNAME);
        this.stack.add(LexicalUnit.BEGINPROG);
        Match(LexicalUnit.BEGINPROG);
        Match(LexicalUnit.PROGNAME);
        Match(LexicalUnit.ENDLINE);
        program.add(new ParseTree(new Symbol(LexicalUnit.BEGINPROG)));
        program.add(new ParseTree(new Symbol(LexicalUnit.PROGNAME)));
        program.add(new ParseTree(new Symbol(LexicalUnit.ENDLINE)));
        program.add(new ParseTree(new Symbol(LexicalUnit.NonTerminal, "Varriables"), Varriables()));
        program.add(new ParseTree(new Symbol(LexicalUnit.NonTerminal, "Code"), Code()));
        Match(LexicalUnit.ENDPROG);
        program.add(new ParseTree(new Symbol(LexicalUnit.ENDPROG)));
        return program;

    }

    /**
     * lefmost derivation of the varriable <Varriables> , we remove the varriable
     * <Varriables> from the stuck and push the derivations if we have the terminal
     * Varriables on the head of the stuck we Match and add it to the parsetree
     * ,else we just remove <varriables> from the stuck
     * 
     * @return ParseTree of Varriables
     */
    private ArrayList<ParseTree> Varriables() {
        ArrayList<ParseTree> VarriablesTree = new ArrayList<ParseTree>();
        this.stack.pop();
        switch (this.token.getType()) {
        case VARIABLES:
            this.rules.add(2);
            this.stack.push(LexicalUnit.ENDLINE);
            this.stack.push(Varriables.VarList);
            this.stack.push(LexicalUnit.VARIABLES);

            VarriablesTree.add(new ParseTree(new Symbol(LexicalUnit.VARIABLES, Match(LexicalUnit.VARIABLES))));
            VarriablesTree.add(new ParseTree(new Symbol(LexicalUnit.NonTerminal, "VarList"), VarList()));
            Match(LexicalUnit.ENDLINE);
            VarriablesTree.add(new ParseTree(new Symbol(LexicalUnit.ENDLINE)));
            break;
        case VARNAME:
            this.rules.add(3);
            VarriablesTree.add(new ParseTree(new Symbol(LexicalUnit.NonTerminal, "EPSILON")));
            break;
        case IF:
            this.rules.add(3);
            VarriablesTree.add(new ParseTree(new Symbol(LexicalUnit.NonTerminal, "EPSILON")));
            break;
        case WHILE:
            this.rules.add(3);
            VarriablesTree.add(new ParseTree(new Symbol(LexicalUnit.NonTerminal, "EPSILON")));
            break;
        case FOR:
            this.rules.add(3);
            VarriablesTree.add(new ParseTree(new Symbol(LexicalUnit.NonTerminal, "EPSILON")));
            break;
        case PRINT:
            this.rules.add(3);
            VarriablesTree.add(new ParseTree(new Symbol(LexicalUnit.NonTerminal, "EPSILON")));
            break;
        case READ:
            this.rules.add(3);
            VarriablesTree.add(new ParseTree(new Symbol(LexicalUnit.NonTerminal, "EPSILON")));
            break;
        case ENDPROG:
            this.rules.add(3);
            VarriablesTree.add(new ParseTree(new Symbol(LexicalUnit.NonTerminal, "EPSILON")));
            break;
        default:
            Syntaxerror(this.token);
        }
        return VarriablesTree;
    }

    /**
     * lefmost derivation of the varriable <VarList> , we remove the varriable
     * <VarList> from the stuck and push the derivations, if we have a terminal on
     * the head of the stuck we Match and add it to the parsetree ,else we call the
     * functions to derivate the varriable
     * 
     * @return ParseTree of VarList
     */
    private ArrayList<ParseTree> VarList() {
        ArrayList<ParseTree> VarList = new ArrayList<ParseTree>();
        this.stack.pop();
        if (this.token.getType().equals(LexicalUnit.VARNAME)) {
            this.rules.add(4);
            this.stack.push(Varriables.VarListP);
            this.stack.push(LexicalUnit.VARNAME);
            VarList.add(new ParseTree(new Symbol(LexicalUnit.VARNAME, Match(LexicalUnit.VARNAME))));
            VarList.add(new ParseTree(new Symbol(LexicalUnit.NonTerminal, "VarListP"), VarListP()));

        } else {
            Syntaxerror(this.token);
        }
        return VarList;
    }

    /**
     * lefmost derivation of the varriable <VarListP> , we remove the varriable
     * <VarListP> from the stuck and push the derivations if we have the terminal
     * COMMA on the head of the stuck we Match and add it to the parsetree ,else we
     * just remove the varriable from the stuck
     * 
     * @return ParseTree of VarListP
     */
    private ArrayList<ParseTree> VarListP() {
        ArrayList<ParseTree> VarListP = new ArrayList<ParseTree>();
        this.stack.pop();
        switch (this.token.getType()) {
        case COMMA:
            this.rules.add(5);
            this.stack.push(Varriables.VarList);
            this.stack.push(LexicalUnit.COMMA);
            Match(LexicalUnit.COMMA);
            VarListP.add(new ParseTree(new Symbol(LexicalUnit.COMMA)));
            VarListP.add(new ParseTree(new Symbol(LexicalUnit.NonTerminal, "VarList"), VarList()));
            break;
        case ENDLINE:
            this.rules.add(6);
            VarListP.add(new ParseTree(new Symbol(LexicalUnit.NonTerminal, "EPSILON")));
            break;
        case RPAREN:
            this.rules.add(6);
            VarListP.add(new ParseTree(new Symbol(LexicalUnit.NonTerminal, "EPSILON")));
            break;
        default:
            Syntaxerror(this.token);

        }
        return VarListP;

    }

    /**
     * lefmost derivation of the varriable <Code> , we remove the varriable <Code>
     * from the stuck and push the derivations if we have the terminals
     * VARNAME,IF,WHILE,FOR,PRINT,READ on the head of the stuck we Match and add it
     * to the parsetree ,else we just remove the varriable from the stuck
     * 
     * @return ParseTree of Code
     */
    private ArrayList<ParseTree> Code() {
        ArrayList<ParseTree> CodeTree = new ArrayList<ParseTree>();
        if (this.token.getType().equals(LexicalUnit.VARNAME) || this.token.getType().equals(LexicalUnit.IF)
                || this.token.getType().equals(LexicalUnit.WHILE) || this.token.getType().equals(LexicalUnit.FOR)
                || this.token.getType().equals(LexicalUnit.PRINT) || this.token.getType().equals(LexicalUnit.READ)) {
            this.rules.add(7);
            this.stack.push(Varriables.Code);
            this.stack.push(LexicalUnit.ENDLINE);
            this.stack.push(Varriables.Instruction);
            CodeTree.add(new ParseTree(new Symbol(LexicalUnit.NonTerminal, "Instructions"), Instructions()));
            CodeTree.add(new ParseTree(new Symbol(LexicalUnit.ENDLINE)));
            Match(LexicalUnit.ENDLINE);
            CodeTree.add(new ParseTree(new Symbol(LexicalUnit.NonTerminal, "Code"), Code()));
        } else if (this.token.getType().equals(LexicalUnit.ENDPROG) || this.token.getType().equals(LexicalUnit.ENDFOR)
                || this.token.getType().equals(LexicalUnit.ENDIF) || this.token.getType().equals(LexicalUnit.ELSE)
                || this.token.getType().equals(LexicalUnit.ENDWHILE)) {
            CodeTree.add(new ParseTree(new Symbol(LexicalUnit.NonTerminal, "EPSILON")));
        } else {

            Syntaxerror(this.token);
        }
        return CodeTree;
    }

    /**
     * lefmost derivation of the varriable <Instructions> , we remove the varriable
     * <Instructions> from the stuck and we call other varriables derivations
     * 
     * @return ParseTree of VarListP
     */
    public ArrayList<ParseTree> Instructions() {
        this.stack.pop();
        switch (this.token.getType()) {
        case VARNAME:
            return Assign();

        case IF:
            return If();

        case WHILE:
            return While();

        case FOR:
            return For();

        case PRINT:
            return Print();

        case READ:
            return Read();

        }
        return null;
    }

    /**
     * lefmost derivation of the varriable <Assign> , we remove the varriable
     * <Assign> from the stuck and push the derivations, we Match and add it to the
     * parsetree
     * 
     * @return ParseTree of Assign
     */
    private ArrayList<ParseTree> Assign() {
        ArrayList<ParseTree> AssignTree = new ArrayList<ParseTree>();
        this.rules.add(9);
        this.stack.push(Varriables.ExprArithTmp);
        this.stack.push(Varriables.ExprArithPrimeTmp);
        this.stack.push(Varriables.ExprArithPrimeBeta);
        this.stack.push(LexicalUnit.ASSIGN);
        this.stack.push(LexicalUnit.VARNAME);

        AssignTree.add(new ParseTree(new Symbol(LexicalUnit.VARNAME, Match(LexicalUnit.VARNAME))));
        AssignTree.add(new ParseTree(new Symbol(LexicalUnit.ASSIGN, Match(LexicalUnit.ASSIGN))));
        AssignTree.add(new ParseTree(new Symbol(LexicalUnit.NonTerminal, "ExprArithPrimeBeta"), ExprArithPrimeBeta()));
        AssignTree.add(new ParseTree(new Symbol(LexicalUnit.NonTerminal, "ExprArithPrimeTmp"), ExprArithPrimeTmp()));
        AssignTree.add(new ParseTree(new Symbol(LexicalUnit.NonTerminal, "ExprArithTmp"), ExprArithTmp()));
        return AssignTree;
    }

    /**
     * lefmost derivation of the varriable <ExprArithTmp> , we remove the varriable
     * <ExprArithTmp> from the stuck and push the derivations if we have the
     * terminals on the head of the stuck we Match and add it to the parsetree ,else
     * we call other derivations functions
     * 
     * @return ParseTree of ExprArithTmp
     */
    private ArrayList<ParseTree> ExprArithTmp() {
        ArrayList<ParseTree> ExprArithTmpTree = new ArrayList<ParseTree>();
        switch (this.token.getType()) {
        case PLUS:
            this.stack.pop();
            this.rules.add(15);
            this.stack.push(Varriables.ExprArithTmp);
            this.stack.push(Varriables.ExprArithPrimeTmp);
            this.stack.push(Varriables.ExprArithPrimeBeta);
            this.stack.push(LexicalUnit.PLUS);
            Match(LexicalUnit.PLUS);
            ExprArithTmpTree.add(new ParseTree(new Symbol(LexicalUnit.PLUS)));
            ExprArithTmpTree.add(
                    new ParseTree(new Symbol(LexicalUnit.NonTerminal, "ExprArithPrimeBeta"), ExprArithPrimeBeta()));
            ExprArithTmpTree
                    .add(new ParseTree(new Symbol(LexicalUnit.NonTerminal, "ExprArithPrimeTmp"), ExprArithPrimeTmp()));
            ExprArithTmpTree.add(new ParseTree(new Symbol(LexicalUnit.NonTerminal, "ExprArithTmp"), ExprArithTmp()));
            break;
        case MINUS:
            this.stack.pop();
            this.rules.add(16);
            this.stack.push(Varriables.ExprArithTmp);
            this.stack.push(Varriables.ExprArithPrimeTmp);
            this.stack.push(Varriables.ExprArithPrimeBeta);
            this.stack.push(LexicalUnit.MINUS);
            Match(LexicalUnit.MINUS);
            ExprArithTmpTree.add(new ParseTree(new Symbol(LexicalUnit.MINUS)));
            ExprArithTmpTree.add(
                    new ParseTree(new Symbol(LexicalUnit.NonTerminal, "ExprArithPrimeBeta"), ExprArithPrimeBeta()));
            ExprArithTmpTree
                    .add(new ParseTree(new Symbol(LexicalUnit.NonTerminal, "ExprArithPrimeTmp"), ExprArithPrimeTmp()));
            ExprArithTmpTree.add(new ParseTree(new Symbol(LexicalUnit.NonTerminal, "ExprArithTmp"), ExprArithTmp()));
            break;
        default:
            this.rules.add(17);
            ExprArithTmpTree.add(new ParseTree(new Symbol(LexicalUnit.NonTerminal, "EPSILON")));
        }
        return ExprArithTmpTree;
    }

    /**
     * lefmost derivation of the varriable <ExprArithPrimeTmp> , we remove the
     * varriable <ExprArithPrimeTmp> from the stuck and push the derivations if we
     * have the terminals on the head of the stuck we Match and add it to the
     * parsetree ,else we call other derivations functions
     * 
     * @return ParseTree of ExprArithPrimeTmp
     */
    private ArrayList<ParseTree> ExprArithPrimeTmp() {
        ArrayList<ParseTree> ExprArithPrimeTmpTree = new ArrayList<ParseTree>();
        switch (this.token.getType()) {
        case TIMES:
            this.stack.pop();
            this.rules.add(21);
            this.stack.push(Varriables.ExprArithPrimeTmp);
            this.stack.push(Varriables.ExprArithPrimeBeta);
            this.stack.push(LexicalUnit.TIMES);
            Match(LexicalUnit.TIMES);
            ExprArithPrimeTmpTree.add(new ParseTree(new Symbol(LexicalUnit.TIMES)));
            ExprArithPrimeTmpTree.add(
                    new ParseTree(new Symbol(LexicalUnit.NonTerminal, "ExprArithPrimeBeta"), ExprArithPrimeBeta()));
            ExprArithPrimeTmpTree
                    .add(new ParseTree(new Symbol(LexicalUnit.NonTerminal, "ExprArithPrimeTmp"), ExprArithPrimeTmp()));

            break;
        case DIVIDE:
            this.stack.pop();
            this.rules.add(22);
            this.stack.push(Varriables.ExprArithPrimeTmp);
            this.stack.push(Varriables.ExprArithPrimeBeta);
            this.stack.push(LexicalUnit.DIVIDE);
            Match(LexicalUnit.DIVIDE);
            ExprArithPrimeTmpTree.add(new ParseTree(new Symbol(LexicalUnit.DIVIDE)));
            ExprArithPrimeTmpTree.add(
                    new ParseTree(new Symbol(LexicalUnit.NonTerminal, "ExprArithPrimeBeta"), ExprArithPrimeBeta()));
            ExprArithPrimeTmpTree
                    .add(new ParseTree(new Symbol(LexicalUnit.NonTerminal, "ExprArithPrimeTmp"), ExprArithPrimeTmp()));

            break;
        default:
            this.rules.add(23);
            ExprArithPrimeTmpTree.add(new ParseTree(new Symbol(LexicalUnit.NonTerminal, "EPSILON")));
        }
        return ExprArithPrimeTmpTree;
    }

    /**
     * lefmost derivation of the varriable <ExprArithPrimeBeta> , we remove the
     * varriable <ExprArithPrimeBeta> from the stuck and push the derivations if we
     * have the terminals on the head of the stuck we Match and add it to the
     * parsetree ,else we call other derivations functions
     * 
     * @return ParseTree of ExprArithPrimeBeta
     */
    private ArrayList<ParseTree> ExprArithPrimeBeta() {
        ArrayList<ParseTree> ExprArithPrimeBetaTee = new ArrayList<ParseTree>();
        this.stack.pop();
        switch (this.token.getType()) {
        case VARNAME:
            this.rules.add(24);

            ExprArithPrimeBetaTee.add(new ParseTree(new Symbol(LexicalUnit.VARNAME, Match(LexicalUnit.VARNAME))));
            break;
        case NUMBER:
            this.rules.add(25);

            ExprArithPrimeBetaTee.add(new ParseTree(new Symbol(LexicalUnit.NUMBER, Match(LexicalUnit.NUMBER))));
            break;
        case LPAREN:
            this.rules.add(26);
            this.stack.push(LexicalUnit.RPAREN);
            this.stack.push(Varriables.ExprArithTmp);
            this.stack.push(Varriables.ExprArithPrimeTmp);
            this.stack.push(Varriables.ExprArithPrimeBeta);
            this.stack.push(LexicalUnit.LPAREN);
            Match(LexicalUnit.LPAREN);
            ExprArithPrimeBetaTee.add(new ParseTree(new Symbol(LexicalUnit.LPAREN)));
            ExprArithPrimeBetaTee.add(
                    new ParseTree(new Symbol(LexicalUnit.NonTerminal, "ExprArithPrimeBeta"), ExprArithPrimeBeta()));
            ExprArithPrimeBetaTee
                    .add(new ParseTree(new Symbol(LexicalUnit.NonTerminal, "ExprArithPrimeTmp"), ExprArithPrimeTmp()));
            ExprArithPrimeBetaTee
                    .add(new ParseTree(new Symbol(LexicalUnit.NonTerminal, "ExprArithTmp"), ExprArithTmp()));
            ExprArithPrimeBetaTee.add(new ParseTree(new Symbol(LexicalUnit.RPAREN)));
            Match(LexicalUnit.RPAREN);
            break;
        case MINUS:
            this.rules.add(27);
            // this.stack.push(Varriables.ExprArithTmp);
            // this.stack.push(Varriables.ExprArithPrimeTmp);
            this.stack.push(Varriables.ExprArithPrimeBeta);
            this.stack.push(LexicalUnit.MINUS);

            ExprArithPrimeBetaTee.add(new ParseTree(new Symbol(LexicalUnit.MINUS, Match(LexicalUnit.MINUS))));
            ExprArithPrimeBetaTee.add(
                    new ParseTree(new Symbol(LexicalUnit.NonTerminal, "ExprArithPrimeBeta"), ExprArithPrimeBeta()));
            break;

        default:
            Syntaxerror(this.token);
        }
        return ExprArithPrimeBetaTee;
    }

    /**
     * lefmost derivation of the varriable <IF> , we remove the varriable <IF> from
     * the stuck and push the derivation if we have the terminals on the head of the
     * stuck we Match and add it to the parsetree ,else we call other derivations
     * functions
     * 
     * @return ParseTree of IF
     */
    private ArrayList<ParseTree> If() {
        ArrayList<ParseTree> IfTree = new ArrayList<ParseTree>();
        this.rules.add(10);
        this.stack.push(Varriables.Ifst);
        this.stack.push(Varriables.Code);
        this.stack.push(LexicalUnit.ENDLINE);
        this.stack.push(LexicalUnit.THEN);
        this.stack.push(LexicalUnit.RPAREN);
        this.stack.push(Varriables.CondBeta);
        this.stack.push(Varriables.CondPrime);
        this.stack.push(LexicalUnit.LPAREN);
        this.stack.push(LexicalUnit.IF);
        Match(LexicalUnit.IF);
        Match(LexicalUnit.LPAREN);
        IfTree.add(new ParseTree(new Symbol(LexicalUnit.IF)));
        IfTree.add(new ParseTree(new Symbol(LexicalUnit.LPAREN)));
        IfTree.add(new ParseTree(new Symbol(LexicalUnit.NonTerminal, "CondPrime"), CondPrime()));
        IfTree.add(new ParseTree(new Symbol(LexicalUnit.NonTerminal, "CondBeta"), CondBeta()));
        IfTree.add(new ParseTree(new Symbol(LexicalUnit.RPAREN)));
        IfTree.add(new ParseTree(new Symbol(LexicalUnit.THEN)));
        IfTree.add(new ParseTree(new Symbol(LexicalUnit.ENDLINE)));
        Match(LexicalUnit.RPAREN);
        Match(LexicalUnit.THEN);
        Match(LexicalUnit.ENDLINE);
        IfTree.add(new ParseTree(new Symbol(LexicalUnit.NonTerminal, "Code"), Code()));
        IfTree.add(new ParseTree(new Symbol(LexicalUnit.NonTerminal, "Ifst"), Ifst()));
        return IfTree;
    }

    /**
     * lefmost derivation of the varriable <CondPrime> , we remove the varriable
     * <CondPrime> from the stuck and push the derivations if we have the terminals
     * on the head of the stuck we Match and add it to the parsetree ,else we call
     * other derivations functions
     * 
     * @return ParseTree of CondPrime
     */
    private ArrayList<ParseTree> CondPrime() {
        ArrayList<ParseTree> CondPrimeTree = new ArrayList<ParseTree>();
        this.stack.pop();
        if (this.token.getType().equals(LexicalUnit.VARNAME) || this.token.getType().equals(LexicalUnit.NUMBER)
                || this.token.getType().equals(LexicalUnit.LPAREN) || this.token.getType().equals(LexicalUnit.MINUS)) {
            this.rules.add(30);
            this.stack.push(Varriables.CondPrimeBeta);
            this.stack.push(Varriables.SimpleCond);
            CondPrimeTree.add(new ParseTree(new Symbol(LexicalUnit.NonTerminal, "SimpleCond"), SimpleCond()));
            CondPrimeTree.add(new ParseTree(new Symbol(LexicalUnit.NonTerminal, "CondPrimeBeta"), CondPrimeBeta()));

        } else if (this.token.getType().equals(LexicalUnit.NOT)) {
            this.rules.add(29);
            this.stack.push(Varriables.CondPrimeBeta);
            this.stack.push(Varriables.SimpleCond);
            this.stack.push(LexicalUnit.NOT);
            CondPrimeTree.add(new ParseTree(new Symbol(LexicalUnit.NOT, Match(LexicalUnit.NOT))));
            CondPrimeTree.add(new ParseTree(new Symbol(LexicalUnit.NonTerminal, "SimpleCond"), SimpleCond()));
            CondPrimeTree.add(new ParseTree(new Symbol(LexicalUnit.NonTerminal, "CondPrimeBeta"), CondPrimeBeta()));
        } else {
            Syntaxerror(this.token);
        }
        return CondPrimeTree;
    }

    /**
     * lefmost derivation of the varriable <CondBeta> , we remove the varriable
     * <CondBeta> from the stuck and push the derivations if we have the terminals
     * on the head of the stuck we Match and add it to the parsetree ,else we call
     * other derivations functions
     * 
     * @return ParseTree of CondBeta
     */
    private ArrayList<ParseTree> CondBeta() {
        ArrayList<ParseTree> CondBetaTree = new ArrayList<ParseTree>();
        this.stack.pop();
        switch (this.token.getType()) {
        case OR:
            this.rules.add(27);
            this.stack.push(Varriables.CondBeta);
            this.stack.push(Varriables.CondPrime);
            this.stack.push(LexicalUnit.OR);
            CondBetaTree.add(new ParseTree(new Symbol(LexicalUnit.OR, Match(LexicalUnit.OR))));
            CondBetaTree.add(new ParseTree(new Symbol(LexicalUnit.NonTerminal, "CondPrime"), CondPrime()));
            CondBetaTree.add(new ParseTree(new Symbol(LexicalUnit.NonTerminal, "CondBeta"), CondBeta()));
            break;
        case RPAREN:
            this.rules.add(28);
            CondBetaTree.add(new ParseTree(new Symbol(LexicalUnit.NonTerminal, "EPSILON")));
            break;
        default:
            Syntaxerror(this.token);
        }
        return CondBetaTree;

    }

    /**
     * lefmost derivation of the varriable <CondPrimeBeta> , we remove the varriable
     * <CondPrimeBeta> from the stuck and push the derivations if we have the
     * terminals on the head of the stuck we Match and add it to the parsetree ,else
     * we call other derivations functions
     * 
     * @return ParseTree of CondPrimeBeta
     */
    private ArrayList<ParseTree> CondPrimeBeta() {
        ArrayList<ParseTree> CondPrimeBetaTree = new ArrayList<ParseTree>();
        this.stack.pop();
        switch (this.token.getType()) {
        case AND:
            this.rules.add(21);
            this.stack.push(Varriables.CondPrimeBeta);
            this.stack.push(Varriables.CondPrime);
            this.stack.push(LexicalUnit.AND);
            CondPrimeBetaTree.add(new ParseTree(new Symbol(LexicalUnit.AND, Match(LexicalUnit.AND))));
            CondPrimeBetaTree.add(new ParseTree(new Symbol(LexicalUnit.NonTerminal, "CondPrime"), CondPrime()));
            CondPrimeBetaTree.add(new ParseTree(new Symbol(LexicalUnit.NonTerminal, "CondPrimeBeta"), CondPrimeBeta()));
            break;
        case OR:
            this.rules.add(32);
            CondPrimeBetaTree.add(new ParseTree(new Symbol(LexicalUnit.NonTerminal, "EPSILON")));
            break;
        case RPAREN:
            this.rules.add(32);
            CondPrimeBetaTree.add(new ParseTree(new Symbol(LexicalUnit.NonTerminal, "EPSILON")));
            break;
        default:
            Syntaxerror(this.token);
        }
        return CondPrimeBetaTree;

    }

    /**
     * lefmost derivation of the varriable <SimpleCond> , we remove the varriable
     * <SimpleCond> from the stuck and push the derivations if we have the terminals
     * on the head of the stuck we Match and add it to the parsetree ,else we call
     * other derivations functions
     * 
     * @return ParseTree of SimpleCond
     */
    private ArrayList<ParseTree> SimpleCond() {
        ArrayList<ParseTree> SimpleCondTree = new ArrayList<ParseTree>();
        this.stack.pop();
        this.rules.add(33);
        this.stack.push(Varriables.ExprArithTmp);
        this.stack.push(Varriables.ExprArithPrimeTmp);
        this.stack.push(Varriables.ExprArithPrimeBeta);
        this.stack.push(Varriables.Comp);
        this.stack.push(Varriables.ExprArithTmp);
        this.stack.push(Varriables.ExprArithPrimeTmp);
        this.stack.push(Varriables.ExprArithPrimeBeta);
        SimpleCondTree
                .add(new ParseTree(new Symbol(LexicalUnit.NonTerminal, "ExprArithPrimeBeta"), ExprArithPrimeBeta()));
        SimpleCondTree
                .add(new ParseTree(new Symbol(LexicalUnit.NonTerminal, "ExprArithPrimeTmp"), ExprArithPrimeTmp()));
        SimpleCondTree.add(new ParseTree(new Symbol(LexicalUnit.NonTerminal, "ExprArithTmp"), ExprArithTmp()));
        SimpleCondTree.add(new ParseTree(new Symbol(LexicalUnit.NonTerminal, "Comp"), Comp()));
        SimpleCondTree
                .add(new ParseTree(new Symbol(LexicalUnit.NonTerminal, "ExprArithPrimeBeta"), ExprArithPrimeBeta()));
        SimpleCondTree
                .add(new ParseTree(new Symbol(LexicalUnit.NonTerminal, "ExprArithPrimeTmp"), ExprArithPrimeTmp()));

        SimpleCondTree.add(new ParseTree(new Symbol(LexicalUnit.NonTerminal, "ExprArithTmp"), ExprArithTmp()));

        return SimpleCondTree;

    }

    /**
     * lefmost derivation of the varriable <Comp> , we remove the varriable <Comp>
     * from the stuck and push the derivations if we have the terminals on the head
     * of the stuck we Match and add it to the parsetree ,else we call other
     * derivations functions
     * 
     * @return ParseTree of Comp
     */
    private ArrayList<ParseTree> Comp() {
        ArrayList<ParseTree> CompTree = new ArrayList<ParseTree>();
        this.stack.pop();
        switch (this.token.getType()) {
        case EQ:
            this.rules.add(34);
            this.stack.push(LexicalUnit.EQ);
            CompTree.add(new ParseTree(new Symbol(LexicalUnit.EQ, Match(LexicalUnit.EQ))));
            break;
        case GEQ:
            this.rules.add(35);
            this.stack.push(LexicalUnit.GEQ);
            CompTree.add(new ParseTree(new Symbol(LexicalUnit.GEQ, Match(LexicalUnit.GEQ))));
            break;
        case GT:
            this.rules.add(36);
            this.stack.push(LexicalUnit.GT);
            CompTree.add(new ParseTree(new Symbol(LexicalUnit.GT, Match(LexicalUnit.GT))));
            break;
        case LEQ:
            this.rules.add(37);
            this.stack.push(LexicalUnit.LEQ);
            CompTree.add(new ParseTree(new Symbol(LexicalUnit.LEQ, Match(LexicalUnit.LEQ))));
            break;
        case LT:
            this.rules.add(38);
            this.stack.push(LexicalUnit.LT);
            CompTree.add(new ParseTree(new Symbol(LexicalUnit.LT, Match(LexicalUnit.LT))));
            break;
        case NEQ:
            this.rules.add(39);
            this.stack.push(LexicalUnit.NEQ);
            CompTree.add(new ParseTree(new Symbol(LexicalUnit.NEQ, Match(LexicalUnit.NEQ))));
            break;
        default:
            Syntaxerror(this.token);
        }
        return CompTree;

    }

    /**
     * lefmost derivation of the varriable <Ifst> , we remove the varriable <Ifst>
     * from the stuck and push the derivations if we have the terminals on the head
     * of the stuck we Match and add it to the parsetree ,else we call other
     * derivations functions
     * 
     * @return ParseTree of Ifst
     */
    private ArrayList<ParseTree> Ifst() {
        ArrayList<ParseTree> IfstTree = new ArrayList<ParseTree>();
        this.stack.pop();
        switch (this.token.getType()) {
        case ELSE:
            this.rules.add(25);
            this.stack.push(LexicalUnit.ENDIF);
            this.stack.push(Varriables.Code);
            this.stack.push(LexicalUnit.ENDLINE);
            this.stack.push(LexicalUnit.ELSE);
            IfstTree.add(new ParseTree(new Symbol(LexicalUnit.ELSE, Match(LexicalUnit.ELSE))));
            IfstTree.add(new ParseTree(new Symbol(LexicalUnit.ENDLINE, Match(LexicalUnit.ENDLINE))));
            IfstTree.add(new ParseTree(new Symbol(LexicalUnit.NonTerminal, "IfstTree"), Code()));
            IfstTree.add(new ParseTree(new Symbol(LexicalUnit.ENDIF, Match(LexicalUnit.ENDIF))));
            break;
        case ENDIF:
            this.rules.add(26);
            this.stack.push(LexicalUnit.ENDIF);
            IfstTree.add(new ParseTree(new Symbol(LexicalUnit.ENDIF, Match(LexicalUnit.ENDIF))));
            break;
        default:
            Syntaxerror(this.token);
        }
        return IfstTree;
    }

    /**
     * lefmost derivation of the varriable <While> , we remove the varriable <While>
     * from the stuck and push the derivations if we have the terminals on the head
     * of the stuck we Match and add it to the parsetree ,else we call other
     * derivations functions
     * 
     * @return ParseTree of While
     */
    private ArrayList<ParseTree> While() {
        ArrayList<ParseTree> whileTree = new ArrayList<ParseTree>();
        this.rules.add(11);
        this.stack.push(LexicalUnit.ENDWHILE);
        this.stack.push(Varriables.Code);
        this.stack.push(LexicalUnit.ENDLINE);
        this.stack.push(LexicalUnit.DO);
        this.stack.push(LexicalUnit.RPAREN);
        this.stack.push(Varriables.CondBeta);
        this.stack.push(Varriables.CondPrime);
        this.stack.push(LexicalUnit.LPAREN);
        this.stack.push(LexicalUnit.WHILE);
        Match(LexicalUnit.WHILE);
        Match(LexicalUnit.LPAREN);
        whileTree.add(new ParseTree(new Symbol(LexicalUnit.WHILE)));
        whileTree.add(new ParseTree(new Symbol(LexicalUnit.LPAREN)));
        whileTree.add(new ParseTree(new Symbol(LexicalUnit.NonTerminal, "CondPrime"), CondPrime()));
        whileTree.add(new ParseTree(new Symbol(LexicalUnit.NonTerminal, "CondBeta"), CondBeta()));
        Match(LexicalUnit.RPAREN);
        Match(LexicalUnit.DO);
        Match(LexicalUnit.ENDLINE);
        whileTree.add(new ParseTree(new Symbol(LexicalUnit.RPAREN)));
        whileTree.add(new ParseTree(new Symbol(LexicalUnit.DO)));
        whileTree.add(new ParseTree(new Symbol(LexicalUnit.ENDLINE)));
        whileTree.add(new ParseTree(new Symbol(LexicalUnit.NonTerminal, "Code"), Code()));
        Match(LexicalUnit.ENDWHILE);
        whileTree.add(new ParseTree(new Symbol(LexicalUnit.ENDWHILE)));
        return whileTree;
    }

    /**
     * lefmost derivation of the varriable <For> , we remove the varriable <For>
     * from the stuck and push the derivations if we have the terminals on the head
     * of the stuck we Match and add it to the parsetree ,else we call other
     * derivations functions
     * 
     * @return ParseTree of For
     */
    private ArrayList<ParseTree> For() {
        ArrayList<ParseTree> forTree = new ArrayList<ParseTree>();
        this.rules.add(12);
        this.stack.push(LexicalUnit.ENDFOR);
        this.stack.push(Varriables.Code);
        this.stack.push(LexicalUnit.ENDLINE);
        this.stack.push(LexicalUnit.DO);
        this.stack.push(Varriables.ExprArithTmp);
        this.stack.push(Varriables.ExprArithPrimeTmp);
        this.stack.push(Varriables.ExprArithPrimeBeta);
        this.stack.push(LexicalUnit.TO);
        this.stack.push(Varriables.ExprArithTmp);
        this.stack.push(Varriables.ExprArithPrimeTmp);
        this.stack.push(Varriables.ExprArithPrimeBeta);
        this.stack.push(LexicalUnit.ASSIGN);
        this.stack.push(LexicalUnit.VARNAME);
        this.stack.push(LexicalUnit.FOR);
        forTree.add(new ParseTree(new Symbol(LexicalUnit.FOR, Match(LexicalUnit.FOR))));
        forTree.add(new ParseTree(new Symbol(LexicalUnit.VARNAME, Match(LexicalUnit.VARNAME))));
        forTree.add(new ParseTree(new Symbol(LexicalUnit.ASSIGN, Match(LexicalUnit.ASSIGN))));
        forTree.add(new ParseTree(new Symbol(LexicalUnit.NonTerminal, "ExprArithPrimeBeta"), ExprArithPrimeBeta()));
        forTree.add(new ParseTree(new Symbol(LexicalUnit.NonTerminal, "ExprArithPrimeTmp"), ExprArithPrimeTmp()));
        forTree.add(new ParseTree(new Symbol(LexicalUnit.NonTerminal, "ExprArithTmp"), ExprArithTmp()));
        Match(LexicalUnit.TO);
        forTree.add(new ParseTree(new Symbol(LexicalUnit.TO)));
        forTree.add(new ParseTree(new Symbol(LexicalUnit.NonTerminal, "ExprArithPrimeBeta"), ExprArithPrimeBeta()));
        forTree.add(new ParseTree(new Symbol(LexicalUnit.NonTerminal, "ExprArithPrimeTmp"), ExprArithPrimeTmp()));
        forTree.add(new ParseTree(new Symbol(LexicalUnit.NonTerminal, "ExprArithTmp"), ExprArithTmp()));
        Match(LexicalUnit.DO);
        Match(LexicalUnit.ENDLINE);
        forTree.add(new ParseTree(new Symbol(LexicalUnit.DO)));
        forTree.add(new ParseTree(new Symbol(LexicalUnit.ENDLINE)));
        forTree.add(new ParseTree(new Symbol(LexicalUnit.NonTerminal, "Code"), Code()));
        Match(LexicalUnit.ENDFOR);
        forTree.add(new ParseTree(new Symbol(LexicalUnit.ENDFOR)));
        return forTree;
    }

    /**
     * lefmost derivation of the varriable <Print> , we remove the varriable <Print>
     * from the stuck and push the derivations if we have the terminals on the head
     * of the stuck we Match and add it to the parsetree ,else we call other
     * derivations functions
     * 
     * @return ParseTree of Print
     */
    private ArrayList<ParseTree> Print() {
        ArrayList<ParseTree> printTree = new ArrayList<ParseTree>();
        this.rules.add(13);
        this.stack.push(LexicalUnit.RPAREN);
        this.stack.push(Varriables.ExpList);
        this.stack.push(LexicalUnit.LPAREN);
        this.stack.push(LexicalUnit.PRINT);
        Match(LexicalUnit.PRINT);
        Match(LexicalUnit.LPAREN);
        printTree.add(new ParseTree(new Symbol(LexicalUnit.PRINT)));
        printTree.add(new ParseTree(new Symbol(LexicalUnit.LPAREN)));
        printTree.add(new ParseTree(new Symbol(LexicalUnit.NonTerminal, "ExpList"), ExpList()));
        Match(LexicalUnit.RPAREN);
        printTree.add(new ParseTree(new Symbol(LexicalUnit.RPAREN)));
        return printTree;
    }

    /**
     * lefmost derivation of the varriable <ExpList> , we remove the varriable
     * <ExpList> from the stuck and push the derivations if we have the terminals on
     * the head of the stuck we Match and add it to the parsetree ,else we call
     * other derivations functions
     * 
     * @return ParseTree of ExpList
     */
    private ArrayList<ParseTree> ExpList() {
        ArrayList<ParseTree> ExpListTree = new ArrayList<ParseTree>();
        this.stack.pop();
        this.rules.add(40);
        this.stack.push(Varriables.ExpListPrime);
        this.stack.push(Varriables.ExprArithTmp);
        this.stack.push(Varriables.ExprArithPrimeTmp);
        this.stack.push(Varriables.ExprArithPrimeBeta);
        ExpListTree.add(new ParseTree(new Symbol(LexicalUnit.NonTerminal, "ExprArithPrimeBeta"), ExprArithPrimeBeta()));
        ExpListTree.add(new ParseTree(new Symbol(LexicalUnit.NonTerminal, "ExprArithPrimeTmp"), ExprArithPrimeTmp()));
        ExpListTree.add(new ParseTree(new Symbol(LexicalUnit.NonTerminal, "ExprArithTmp"), ExprArithTmp()));
        ExpListTree.add(new ParseTree(new Symbol(LexicalUnit.NonTerminal, "ExpListPrime"), ExpListPrime()));
        return ExpListTree;
    }

    /**
     * lefmost derivation of the varriable <ExpListPrime> , we remove the varriable
     * <ExpListPrime> from the stuck and push the derivations if we have the
     * terminals on the head of the stuck we Match and add it to the parsetree ,else
     * we call other derivations functions
     * 
     * @return ParseTree of ExpListPrime
     */
    private ArrayList<ParseTree> ExpListPrime() {
        ArrayList<ParseTree> ExpListPrimeTree = new ArrayList<ParseTree>();
        this.stack.pop();
        switch (this.token.getType()) {
        case COMMA:
            this.rules.add(41);
            this.stack.push(Varriables.ExpList);
            this.stack.push(LexicalUnit.COMMA);
            Match(LexicalUnit.COMMA);
            ExpListPrimeTree.add(new ParseTree(new Symbol(LexicalUnit.COMMA)));
            ExpListPrimeTree.add(new ParseTree(new Symbol(LexicalUnit.NonTerminal, "ExpList"), ExpList()));
            break;
        case RPAREN:
            this.rules.add(42);
            ExpListPrimeTree.add(new ParseTree(new Symbol(LexicalUnit.NonTerminal, "EPSILON")));
            break;
        default:
            Syntaxerror(this.token);
        }
        return ExpListPrimeTree;
    }

    /**
     * lefmost derivation of the varriable <Read> , we remove the varriable <Read>
     * from the stuck and push the derivations if we have the terminals on the head
     * of the stuck we Match and add it to the parsetree ,else we call other
     * derivations functions
     * 
     * @return ParseTree of Read
     */
    private ArrayList<ParseTree> Read() {
        ArrayList<ParseTree> ReadTree = new ArrayList<ParseTree>();
        this.rules.add(14);
        this.stack.push(LexicalUnit.RPAREN);
        this.stack.push(Varriables.VarList);
        this.stack.push(LexicalUnit.LPAREN);
        this.stack.push(LexicalUnit.READ);
        Match(LexicalUnit.READ);
        Match(LexicalUnit.LPAREN);
        ReadTree.add(new ParseTree(new Symbol(LexicalUnit.READ)));
        ReadTree.add(new ParseTree(new Symbol(LexicalUnit.LPAREN)));
        ReadTree.add(new ParseTree(new Symbol(LexicalUnit.NonTerminal, "VarList"), VarList()));
        Match(LexicalUnit.RPAREN);
        ReadTree.add(new ParseTree(new Symbol(LexicalUnit.RPAREN)));
        return ReadTree;
    }

    /**
     * 
     * @param lbl the current token to match
     */
    private Object Match(LexicalUnit lbl) {
        try {
            Object tkn = this.token.getValue();
            if (this.token.getType().equals(lbl)) {

                this.stack.pop();
                NextToken();
                while (this.token.getType().equals(lbl) && lbl == LexicalUnit.ENDLINE) {
                    NextToken();
                }
                return tkn;
            } else {
                Syntaxerror(this.token);
            }
        } catch (Exception e) {
            System.out.println("Empty Stack");
        }
        return null;
    }

    /**
     * 
     * @param tkn the current token symbol
     */
    public void Syntaxerror(Symbol tkn) {
        System.out.println("NoN Expected Token " + tkn.getType() + " found , line :" + tkn.getLine());
        System.exit(-1);
    }

    /**
     * 
     * @return list of rules
     */
    public ArrayList<Integer> Rules() {
        return this.rules;
    }
}